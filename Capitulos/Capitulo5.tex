% vim: spelllang=es

\chapter{Implementación}

\section{Metodología}

Antes de nada, es importante aprender un poco sobre cómo realizar cambios en el
código de Tremor eficientemente. Este proyecto modificará gran cantidad de
líneas y cuanto más rápido sea el desarrollo, menos problemas habrán. Esto se
puede cubrir de forma específica al lenguaje Rust, con trucos o consejos que
puedan facilitar el desarrollo, o de forma más general, con la estrategia de
trabajo a seguir. En esta sección se cubrirá lo último, dado que es menos un
detalle de implementación.

TODO: podría mencionar trucos relacionados con Rust en detalle (desactivar
algunos warnings, o quitar statements \rust{use}), pero no creo que sea tan
importante en este caso y el documento ya es bastante largo.

La metodología fue insipirada por mis mentores, que lo denominaron el ``Just
Make it Work'', o \work. Se basa en que, inicialmente, con lo que más problemas
tenía era el perderme en los detalles. Pero ciertamente, primero de todo lo
importante es que ``funcione''. Siempre y cuando el sistema de plugins se pueda
compilar y ejecutar, lo siguiente es secundario:

TODO: alguna traducción de "just make it work" un poco más natural? "Solo que
funcione"? "No te líes, que funcione primero"?

\begin{itemize}
    \item Código ``feo'' (no idiomático, repetitivo o desordenado).

    \item Código de bajo rendimiento.

    \item Documentación pobre.

    \item No tener tests.

    \item No aplicar sugerencias recomendadas por \emph{linters} (en el caso de
        Rust, \emph{Clippy}).

\end{itemize}

TODO: el siguiente párrafo puede no gustarle a alguno de ingeniería del software
porque rompe todas las metodologías de desarrollo que tienen, pero fue como
sinceramente ocurrió.

El no trabajar con tests es discutible, dado que depende de si el programador
prefiere seguir un desarrollo basado en tests. Sin embargo, personalmente no
sentí la necesidad de escribir ningún test en este caso, al menos al principio.
Gracias al sistema fuertemente tipado de Rust, fue principalmente un
\emph{desarrollo basado en el compilador}. Mi progreso se basaba en realizar
algunos cambios y posteriormente intentar que los aceptara el compilador,
repetidamente. Únicamente avancé a la parte de tests cuando todo parecía
funcionar manualmente y estaba lo suficientemente satisfecho con el resultado.

Adicionalmente, las optimizaciones prematuras son la fuente de todos los
problemas. No es algo que sea importante aún. Solo una vez terminada la primera
iteración se puede dedicar más tiempo a medir el rendimiento para saber cuáles
optimizaciones merecen la pena. Notar que sí es importante escoger un
\emph{método o tecnología} que sea apropiado en términos de rendimiento; fue por
ello por lo que se descartó WebAssembly o IPC en el capítulo anterior. Pero
definitivamente el desarrollador debería rendirse en, por ejemplo, evitar una
conversión entre dos tipos innecesaria que posiblemente no afecte al rendimiento
al fin y al cabo.

Lo que quería dejar claro el equipo de Tremor es que todos los tests, limpiezas
u optimizaciones que intentes realizar en este momento acabará muy probablemente
siendo en vano. Se llegará a un punto en el que no se pueda continuar y que
requiera repensar y reescribir gran parte del trabajo. Cuando todo compile y
aparentemente funcione correctamente, se puede dedicar esfuerzo a trabajar en
estos temas secundarios. Si algo no importante está llevando demasiado tiempo,
se debería marcar como TODO o FIXME y dejarlo para otro momento.

Notar que no hay problema con ``gastar'' el tiempo con métodos que acaban siendo
incorrectos, porque realmente no se está ``gastando'' nada; son un paso
necesario para llegar a la solución final. Pero es doloroso tener que eliminar
código al que le has dedicado tiempo, así que al menos debería intentarse
minimizar el impacto que esto tenga.

\section{\abistable}

Dado que \abistable va a ser la librería principal en la que se basará el
sistema de plugins, es importante entender cómo funciona al completo. Además de
conocer los detalles de implementación, es importante conocer cómo \abistable
soluciona los problemas a tener en cuenta para implementar un sistema de
plugins:

\subsection{Versionado}

\abistable especifica lo siguiente respecto a su sistema de
seguridad~\cite{abistable_safety}:

\begin{itemize}
    \item El ABI de \abistable se comprueba siempre. Cada versión \code{0.y.0} y
        \code{x.0.0} de \abistable define su propio ABI, que es incompatible
        con versiones anteriores.

    \item Los tipos se comprueban recursivamente cuando se carga una librería
        dinámica, antes de llamar ninguna función.

\end{itemize}

Todo esto se basa en el \trait \rust{StableAbi}, indicador de que un tipo es
seguro para FFI. Contiene información sobre la estructura en memoria y puede ser
derivado automáticamente. Todos los tipos exportados por \abistable, además de
usar el ABI de C, implementan dicho \trait. Por tanto, si queremos declarar
nuestro propio tipo para usar con \abistable, ademaś de marcarlo con
\rust{#[repr(C)]}, tendremos que añadir \rust{#[derive(StableAbi)]}.

\subsection{Cargado de plugins}

\subsection{Exportando un plugin}

Es importante mantener la interfaz de plugins lo más simple posible. Los
detalles de comunicación deberían dejarse a la runtime, de forma que los plugins
se limiten a exportar una lista de funciones síncronas. De esta forma, se podrá
evitar pasar tipos complejos (\rust{async}, canales de comunicación, etc) entre
la runtime y los plugins, que implicaría una carga de trabajo mucho más alta.

Una vez esta interfaz de bajo nivel se defina, se puede crear un \emph{wrapper}
de más alto nivel en la runtime que se encargue de la comunicación y de mejorar
su usabilidad dentro de Tremor. Esto mismo lo hacen otras \crates como
\cratelink{rdkafka}, que implementa una capa de abstracción asíncrona sobre su
interfaz de C en \cratelink{rdkafka-sys}.

\subsection{Gestión de pánicos}

Actualmente, lanzar pánicos a través del FFI es comportamiento no
definido~\cite[FFI and Panics]{nomicon}. Aunque el programa aborte en la mayoría
de los casos, no existe ninguna garantía de que vaya a suceder así; podría
continuar en un estado inválido, con cualquier tipo de consecuencia.

La solución más directa es usar la función \rust{std::panic::catch_unwind}, que,
para casos excepcionales como este, puede parar la propagación de pánicos cuando
sea llamada. Se podría usar en todas las funciones exportadas por el plugin
internamente, y en caso de producirse un pánico se abortaría el programa, en
lugar de dejar que se propague a la runtime, que sería indefinido.

También es posible configurar el programa para que aborte cuando se produzca un
pánico, en vez de propagarlo. De esta forma, no se llegaría a invocar
comportamiento no definido y se mantendría un rendimiento máximo --- capturar
pánicos tiene un coste. Sin embargo, implica varias desventajas importantes: al
abortar, no se tendrá acceso a la información de \emph{debug} que dan los
pánicos, tampoco se limpiará el estado del programa, y desde la runtime es
imposible saber si el plugin ha configurado los pánicos para que aborten. Esto
último será posible en el futuro, una vez \textcite{pluggablepanic} llegue a una
versión estable.

Esto es algo que \abistable ha tenido en cuenta desde el principio. Antes de que
un pánico se vaya a propagar de plugin a runtime, la librería abortará el
programa por completo. Esta parte se realiza de forma transparente; no hace
falta que el desarrollador se preocupe en ningún momento por ello.

La solución de \abistable no es perfecta por tener un pequeño coste de
rendimiento y por imposibilitar el recuperarse de errores en los plugins. En una
futura versión de Tremor, podría ser posible reiniciar plugins en caso de que
dejen de funcionar para mejorar la resiliencia a fallos.

El equipo de Rust conoce esta limitación y está trabajando en mejorar la
situación. En una futura versión, planea definir cuándo se puede propagar un
pánico de forma más precisa~\cite{cunwind}.

\subsection{Programación asíncrona}

El objetivo inicial era simplificar la interfaz lo suficiente como para que no
sea necesario tratar aspectos como programación asíncrona en el PDK. Esto
terminó siendo inevitable, dado que la asincronía es uno de los pilares de
Tremor.

TODO: podría poner un ejemplo de cómo se usa esta librería (está en un
comentario aquí), pero creo que es demasiado detalle.

% \begin{minted}{rust}
% // Así funciona la programación asíncrona en Rust; la primera
% // función es prácticamente equivalente a la segunda.
% async fn example() -> String {
%     read_file().await
% }
% fn example() -> impl Future<Output = String> {
%     async {
%         read_file().await
%     }
% }
%
% // No pueden haber genéricos en FFI, por lo que ahora `Future`
% // es un tipo concreto `FfiFuture` en vez de un trait. La
% // conversión de `Future` a `FfiFuture` se puede realizar con
% // `into_ffi`.
% fn example() -> FfiFuture<String> {
%     async move {
%         read_file().await
%     }
%     .into_ffi()
% }
% // `FfiFuture<T>` implementa `Future<Output = T>`, por lo que
% // su uso es el mismo.
% async fn user() {
%     example().await
% }
% \end{minted}

Para poder usar \rust{async} con el ABI de C se puede recurrir a la \crate
\cratelink{async_ffi}, cuyo único problema era no tener soporte para \abistable.
Al no implementar el \trait \rust{StableAbi}, no se podía usar en la interfaz
del PDK, por lo que tuve que abrir un pull request para hacerlo yo
mismo~\cite{asyncfficontrib}. El uso de esta librería resulta en código más
verboso, pero esto se podría mejorar en el futuro con un macro
procedural~\cite{asyncffimacro}.

\subsection{Seguridad en hilos}

\abistable utiliza la \crate \cratelink{libloading} internamente, cuya gestión
de errores no es segura en hilos en algunas plataformas, como \code{dlerror} en
FreeBSD~\cite{thsafe_libloading}\cite{thsafe_openbsd}. Sí que lo es en
Linux~\cite{thsafe_linux}, macOS~\cite{thsafe_macos} y Windows~\cite{thsafe_ms},
así que en el caso de Tremor no hace falta preocuparse por esto.

Será importante tener esto en cuenta en el futuro; al añadir soporte para un
nuevo sistema operativo habrá que asegurarse de que su gestión de errores sea
segura en hilos. En caso contrario, deberá actualizarse \code{libloading} para
sincronizar el acceso con un mútex interno, como lo hace la \crate
\cratelink{dlopen}~\cite{thsafe_dlopen}. Notar que esta librería es también
mejorable, dado que usa el mútex siempre, incluso en sistemas operativos donde
el sistema de errores sí es seguro en hilos~\cite{thsafe_dlopen_issue}.

\subsection{Rendimiento}\label{abiperf}

Un último punto vital a tener en cuenta es el coste de realizar conversiones
entre tipos de la librería estándar y tipos de \abistable. Esto se dará en
numerosas ocasiones, dado que usar \abistable cuando no es necesario es
subóptimo para tanto el rendimiento como la usabilidad. Y si, por ejemplo,
convertir un \rust{Vec<T>} a un \rust{RVec<T>} tuviese complejidad $O(n)$,
probablemente \abistable tendría que ser descartado como la solución escogida.

Afortunadamente, tras analizar la implementación de tipos como \rust{RVec<T>},
\rust{RSlice<T>}, \rust{RStr} o \rust{RString}, estas conversiones únicamente
consisten en transferir un puntero con los datos, sin necesidad de copiar nada.
Es decir, las conversiones que realizaremos serán $O(1)$.

\section{Conversión al ABI de C}

TODO: resumir y enlazar al anexo

\subsection{Problemas con varianza y subtipado}

TODO: resumir y enlazar al anexo

\subsection{Optimizaciones}

TODO: mencionar arreglos de halfbrown y similares
