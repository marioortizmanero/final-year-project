% vim: spelllang=es

\chapter{Breve introducción a Rust}\label{ch:rust}

Dado que Rust es un lenguaje de programación que tan solo anunció su primera
versión en 2015, aún no es conocido por muchos desarrolladores. Este proyecto
requiere ser familiar con cómo funciona, por lo que en este capítulo se
introducirán los conceptos más básicos necesarios. Sí que se asume conocimiento
de lenguajes de propósito general, como C, C++, Python o Java.

Sin embargo, es posible que se omitan algunos conceptos o que algunas
explicaciones no sean completamente precisas por razones de simplicidad.
\textcite{rustfullbook} es el libro oficial para aprender Rust por completo,
pero es una lectura larga y posiblemente demasiado exhaustiva. Para mayor
brevedad, se recomienda leer \textcite{rustprofessionals},
\textcite{rustgentleintro} o \textcite{rust30min}.

La comunidad dispone de otros libros que explican aspectos más avanzados del
lenguaje en específico, como \unsafe o la programación asíncrona. En esos casos,
se recomienda leer \textcite{rustnomicon} y \textcite{rustasyncbook},
respectivamente.

TODO: revisar traducciones del libro o similares para asegurarse de que la
terminología es la misma.

\section{¿Qué es Rust?}

Rust es un lenguaje de programación de sistemas compilado y de propósito
general. Su objetivo es maximizar rendimiento y usabilidad, esto último
basándose en seguridad integrada en el lenguaje, en vez de en el \

\section{Primeros pasos}

Comenzando por el clásico ``Hola Mundo'', se incluyen algunos ejemplos de cómo
es la sintaxis de Rust más básica. El programa se podría ejecutar fácilmente con
\emph{Cargo}, el administrador de dependencias oficial, o específicamente con el
comando \code{cargo run}.

\begin{minted}{rust}
fn main() {
    println!("Hello World!");
}
\end{minted}

\code{main} es nuestra función principal, que invoca al macro \emph{println}
para escribir por pantalla. Esto se sabe porque, a diferencia de una llamada a
función, la invocación termina con una exclamación (\code{!}).

Los bloques básicos (\code{if}, \code{else}, \code{while}, \code{for}) son los
mismos que en otros lenguajes, con la introducción de \code{match}, que permite
extraer patrones.

\begin{minted}{rust}
fn factorial(i: u64) -> u64 {
    match i {
        0 => 1,
        n => n * factorial(n-1)
    }
}
\end{minted}

\section{Tipos de datos básicos}

* Struct
* Enum
* Trait

\section{Librería estándar}

De forma similar a C++, Rust posee tipos genéricos. Esto permite la
implementación de una librería estándar flexible, con varias estructuras de
datos importantes a conocer:

\begin{itemize}
    \item Tipos primitivos:
        \begin{itemize}
            \item Carácteres con \code{char}.

            \item Punto flotante con \code{f32} y \code{f64}.

            \item Booleanos con \code{bool}.

            \item Enteros: \code{u8}, \code{i8}, \code{u16}, \code{i16},
                \code{u32}, \code{i32}, \code{u64}, \code{i64}, e incluso
                \code{i128} y \code{u128} en las arquitecturas que lo soportan.

            \item Vectores de tamaño fijo: por ejemplo \code{[1, 2, 3, 4, 5]}.

            \item N-tuplas como \code{(1, true, 9.2)}.

            \item El tipo ``unidad'', \code{()}, equivalente a \code{void} en C
                o C++.

            \item Punteros básicos con \code{*const T} o \code{*mut T}.

        \end{itemize}

    \item \code{Vec<T>} representa un vector contiguo y redimensionable.

    \item \code{HashMap<K, V>} es una tabla hash, genérica respecto a su clave
        \code{K} y su valor \code{V}. No se encuentra en el preludio, por lo que
        requeriría la siguiente declaración, similar a un \code{import} de Java:

\begin{minted}{rust}
use std::collections::HashMap;
\end{minted}

    \item \code{Box<T>}, usado para localizar un tipo \code{T} en memoria.
        Incluye el tamaño que ocupa \code{T}.

    \item \code{str} es una cadena UTF-8 de solo lectura, típicamente usada con
        una referencia \code{&str}. Va acompañada por su longitud, por lo que no
        hace falta terminarla con \code{\0}, a diferencia de C. \code{String} es
        su versión modificable asignada en memoria.

\end{itemize}

\section{Gestión de errores}

En Rust, los errores se indican con el tipo \code{Result<T, E>}. Este se trata
de una enumeración cuyo valor puede ser \code{Ok(T)}, con el resultado obtenido
satisfactoriamente, o \code{Err(E)}, con el tipo de error que ha sucedido. Dado
que es un tipo nuevo, si el programador se olvidase de comprobar errores, el
programa no compilaría. Se puede usar \code{match} para comprobar el resultado,
o una serie de funciones disponibles para hacer el proceso más ergonómico:

\begin{minted}{rust}
match load_file(input) {
    Ok(data) => /* ... */,
    Err(e) => eprintln!("Error: {e}"),
}
\end{minted}

En caso de que se produjera un error del que el programa no se puediera
recuperar, como quedarse sin memoria o un fallo inesperado en la implementación,
se usa la funcionalidad de \emph{pánicos}. Un pánico se propaga de forma similar
a una excepción de C++ o Java, y terminará la ejecución por completo. Esto se
puede invocar con el macro \code{panic!} o utilidades similares.

\section{Macros}

Rust da soporte para dos tipos de macros: \emph{declarativos} y
\emph{procedurales}. Ambos permiten generar código a tiempo de compilación, pero
se diferencian principalmente en la flexibilidad que ofrecen, a coste de un
coste de desarrollo mayor o menor.

Los macros declarativos se crean con una sintaxis especializada, similar a un
\code{match} con patrones de tokens como entrada, y los tokens modificados como
salida. Son similares a los macros de C o C++, pero más potentes e higiénicos
(i.e., su expansión no captura identificadores accidentalmente).

Los macros procedurales se describen como extensiones del lenguaje.
Esencialmente, ejecutan código en la compilación que consume y produce sintaxis
de Rust. Consisten en directamente transformar el Árbol de Sintaxis Abstracta
(AST)~\cite{procmacrosref}. Consecuentemente, su complejidad es mucho mayor,
pero expanden las posibilidades de los macros enormemente.

\begin{minted}{rust}
some_macro!(1, 2, 3); // Puede ser tanto declarativo como procedural
\end{minted}

\begin{minted}{rust}
// Sintaxis típica de invocación de un macro
some_macro! {
    fn some_function() { /* ... */ }
}

// También permitido en el caso de los procedurales
#[some_macro]
fn some_function() { /* ... */ }
\end{minted}

Finalmente, los macros procedurales se pueden declarar de forma que
\emph{deriven} (implementen automáticamente) un \trait. Esto evita escribir
código repetitivo de forma muy sencilla:

\begin{minted}{rust}
// Con un macro `derive` para el trait `Debug`, que sirve para
// mostrar variables por pantalla.
#[derive(Debug)]
struct X(i32);

// Sin ellos sería lo siguiente. Como es trivial se puede
// simplificar en un macro procedural de tipo `derive`.
impl fmt::Debug for X {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self.0)
    }
}
\end{minted}

\section{Programación asíncrona}

Como muchos lenguajes modernos, Rust da soporte a la programación asíncrona, un
modelo de programación concurrente. Sin entrar en excesivo detalle, esta permite
tener una gran cantidad de \emph{tareas} concurrentes ejecutándose sobre unos
pocos hilos del Sistema Operativo. Su caso de uso principal es programas cuyo
rendimiento está limitado por operaciones de entrada y salida, como servidores o
bases de datos~\cite{rustasyncbook}.

\begin{minted}{rust}
// Con `async` se indica que la función es asíncrona.
async fn get_two_sites_async() {
    // Creación de dos "futuros" que, al completarse, descargarán
    // asíncronamente las páginas web. Similar a la creación de
    // un nuevo hilo.
    let future_one = download_async("https://www.foo.com");
    let future_two = download_async("https://www.bar.com");

    // Ejecutar dos tareas. similar a esperar la terminación de
    // los hilos.
    join!(future_one, future_two);

    // Con `.await` se puede esperar a la terminación de un futuro
    // individual.
    let future_three = download_async("https://www.bar.com").await;
}
\end{minted}
