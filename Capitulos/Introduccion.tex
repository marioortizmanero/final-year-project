% vim: spelllang=es

\chapter{Introducción}
\pagenumbering{arabic}

\section{Contexto}

TODO: quizá algunos footnotes podrían cambiarse por referencias aquí?

TODO: es ``fondos monetarios'' redundante? Se entiende con solo ``fondos''?

TODO: a lo mejor me he pasado con la intro ahora? Pero la verdad que creo que es
una historia bastante interesante.

Este proyecto ha sido organizado y financiado por \emph{Wayfair}, una empresa
estadounidense de comercio digital de muebles y artículos del
hogar\footnote{\url{https://www.wayfair.com/}}. Actualmente, ofrece 14 millones
de ítems de más de 11.000 proveedores globales~\cite{wayfairItems} e ingresó
13.700 millones de dólares en 2021~\cite{wayfairRevenue}.

Se trata de una entidad de gran tamaño, lo que se refleja en su cantidad
disponible de datos o \emph{logs} para describir el comportamiento de sus
servicios. Estos son de vital importancia, dado que permiten encontrar errores
en sus sistemas y ayudan a medir el rendimiento del negocio.

Los logs no suelen seguir un formato único ni necesariamente estructurado (es
decir, texto plano en vez de JSON o XML). Por tanto, para poderlos usar es
necesario algún tipo de procesado, que también incluye ignorar información
redundante o transformar ciertos valores. Este paso se llevaba a cabo con el
sistema de procesado de datos \textcite{logstash}.

A medida que crecía la empresa, estas herramientas de observabilidad dejaban de
ser apropiadas. Cada día, Wayfair procesaba 100 \emph{terabytes} de logs. Para
visualizar mejor esta cantidad, si se escribieran en papel, la pila resultante
sería de unos 5.400 kilómetros, o en otras palabras, 5 idas y vueltas a la
Estación Espacial Internacional. El coste mensual de esta infraestructura
alcanzaba unos 40,000 dólares\footnote{Las cantidades mencionadas en esta
sección son aproximadas, para dar una representación del tamaño de datos
procesados y su coste.}.

El problema principal residía en Logstash, escrito en Java y con un propósito de
uso general en vez de especializado en rendimiento y escalabilidad. La solución
de Wayfair fue crear la alternativa \emph{Tremor}. Esta nueva herramienta está
escrita con el lenguaje de programación Rust, que ofrece un rendimiento similar
a C o C++ con una mayor seguridad. Adicionalmente, implementa técnicas para
maximizar la eficiencia, como SIMD, asincronía o, en un futuro cercano,
\emph{clustering}. Una vez la primera versión de Tremor fue publicada, su
rendimiento se redujo a 780 dólares mensuales, 50 veces menos que el coste
original~\cite{tremorcon_lll}.

Tremor ha evolucionado desde entonces, y ha expandido sus posibilidades más allá
de logs a algo más abstracto, los \emph{eventos}. Ahora soporta una mayor
cantidad de software de donde recibir y enviar eventos, e incluso implementa su
propio lenguaje de procesado, reminiscente de SQL. El proyecto se lanzó como
código abierto, y aunque el equipo de desarrollo sigue siendo principalmente de
Wayfair, cualquiera puede contribuir.

Posteriormente, Tremor se unió a la \emph{Cloud Native Computing
Foundation~(CNCF)}\footnote{\url{https://www.cncf.io/}}, principalmente conocido
por mantener \textcite{k8s}. Asimismo, CNCF es parte de la organización
\emph{Linux Foundation~(LFX)}\footnote{\url{https://www.linuxfoundation.org/}},
que además del famoso kernel también ayuda a todo tipo de proyectos, como
Node.js o Let's Encrypt~\cite{lfx_projects}.

Formalmente, el trabajo se ha llevado a cabo gracias a la iniciativa \emph{LFX
Mentorship}, que promueve el aprendizaje de desarrolladores de código abierto,
proporcionando una plataforma transparente y facilitando un sistema de
pagos~\cite{lfx_mentorship}. En ella, proyectos de código abierto especifican
una tarea concreta a realizar, proporcionando a cambio un mentor que le guíe
durante el proceso y una ayuda monetaria.

TODO: debería especificar el dinero que recibí? O no importa?

El título de este proyecto en la plataforma de LFX es ``CNCF -- Tremor: Add
plugin support for tremor (PDK)''\footnote{Página oficial de la iniciativa:
\url{https://mentorship.lfx.linuxfoundation.org/project/b90f7174-fc53-40bc-b9e2-9905f88c38ff}}\footnote{\emph{Tracking
issue} en GitHub:
\url{https://github.com/tremor-rs/tremor-runtime/issues/791}}\footnote{RFC en la
documentación de Tremor:
\url{https://www.tremor.rs/rfc/accepted/plugin-development-kit/}}, es decir,
desarrollar un sistema de plugins para Tremor. La longitud original era de tres
meses, pero se acabó alargando a unos diez meses. Disponía de tres mentores ---
los desarrolladores principales de Tremor ---, que me ayudaron a entender el
funcionamiento interno del programa y dieron consejo cuando era necesario.

\section{Objetivo}

La tarea a llevar a cabo es la implementación de un sistema de plugins, también
denominado \emph{Plugin Development Kit~(PDK)}, para la base de código ya
existente de Tremor. El programa se dividirá en dos partes: la \emph{runtime} y
los \emph{plugins}. Estos últimos son componentes individuales que implementan
cualquier tipo de funcionalidad, y la runtime es capaz de cargarlos y usarlos
dinámicamente en el programa. Una comparación de más alto nivel se podría dar en
un móvil: el hecho de que el sistema operativo (runtime) pueda instalar
cualquier aplicación (plugin) lo hace mucho más flexible que un dispositivo que
únicamente tuviera una serie de aplicaciones predefinidas.

En el caso de Tremor, un plugin podría dar soporte para recibir eventos de
Apache Kafka o para enviarlos a Postgres. La runtime debería ser capaz de cargar
esa funcionalidad mientras se está ejecutando el programa, en vez de mientras se
esté compilando. Dividir el binario de Tremor en varios componentes más pequeños
compilables independientemente implican una reducción en los tiempos de
compilación de cada uno de ellos, que era el objetivo principal del proyecto.

Existen varias tecnologías disponibles para este sistema de plugins. Se
investigarán las más importantes antes de implementarlo, pero el equipo de
Tremor pensaba usar \emph{cargado dinámico} desde el principio. El concepto es
simple: tanto la runtime como los plugins son binarios nativos (es decir, código
máquina). Mediante una interfaz de acceso binario establecida, denominada
\emph{Application Binary Interface~(ABI)}, la runtime es capaz de acceder a
funciones y recursos en los plugins.

El \emph{cargado dinámico} es un método especialmente popular en el lenguaje de
programación C, dado que su interfaz de comunicación es relativamente sencilla.
Asimismo, se trata de una solución altamente eficiente, dado que la comunicación
es binaria y directa. Las características de Tremor implican que el método a
usar debería tener un alto rendimiento, así que el cargado dinámico una de las
mejores opciones disponibles.

Sin embargo, lenguajes modernos como C++ o Rust no especifican estrictamente un
ABI, dado que implementan características más complejas como excepciones o tipos
genéricos. En el caso concreto de Rust, si se compila la \emph{runtime} y los
\emph{plugins} separadamente, no existe ninguna garantía de que la
representación binaria de los datos o de que la convención de llamada a
funciones --- entre otros --- sea la misma.

Por tanto, el cargado dinámicamente es imposible puramente con Rust. Se debe
recurrir a otro ABI que sí sea estable, como el de C. Todas las funciones y
tipos que se usen en la comunicación entre runtime y plugins deberán declararse
siguiendo el estándar de C. Los tipos seguirán unas reglas que definen cómo se
representan en memoria, y las funciones tendrán que seguir una convención
específica.

El problema principal con Tremor es que, al estar escrito puramente con Rust,
todas sus funciones y tipos internos también se declaran con Rust. Este proyecto
tendrá que desarrollar un método para transformar tipos de Rust a C y viceversa
para poder interactuar con plugins, de forma que se pueda seguir usando Rust
para todo lo demás en Tremor.

\section{Motivación}

\subsection{Tiempos de compilación}

% TODO: incluir modo release?
Actualmente, el problema más importante en Tremor es sus tiempos de compilación.
En un ordenador de gama media de \~{}600 € como el Dell Vostro 5481, compilar el
binario \code{tremor} desde cero requiere de más de 7 minutos en modo debug.
Incluso en el caso de cambios incrementales (una vez las dependencias ya han
sido compiladas), hay que esperar unos 10 segundos. Esto no es una buena
experiencia de desarrollo e impide que nuevos programadores se unan a la
comunidad de Tremor.

Debido a la naturaleza del programa, este problema solo empeorará con el tiempo.
Tremor debe tener soporte para un gran número de protocolos (e.g., TCP o UDP),
software (e.g., Kafka o PostgreSQL) y codecs (e.g., JSON o YAML). El número de
dependencias continuará incrementando hasta que imposibilite la creación de
nuevas prestaciones en Tremor.

Los problemas relacionados con tiempos de compilación excesivamente largos no se
limitan a Tremor. Es uno de las mayores críticas que recibe Rust y un 61\% de
sus usuarios declaran que aún se necesita trabajo para mejorar la
situación~\cite{rustsurvey}.

\subsection{Extensibilidad}

TODO

\subsection{Modularidad}

Otra ventaja que provee un sistema de plugins es modularidad; ser capaz de
tratar la runtime y los plugins de forma separada suele resultar en una
arquitectura más limpia~\cite{baldwin2000design}. También hace posible el
desacoplamiento del ejecutable y sus componentes; algunas dependencias tienen un
ciclo de versionado más rápido que otras y generalmente es más conveniente
actualizar únicamente un plugin, en lugar del programa por completo.

\subsection{Aprender de otros}

Otros proyectos maduros con características similares a las de Tremor, como
\textcite{nginx} o \textcite{apachehttpserver}, llevan beneficiándose de un
sistema de plugins desde hace mucho. Informan mejorías en flexibilidad,
extensibilidad y facilidad de
desarrollo~\cite{nginxPluginsAdvantages}\cite{apachePluginsAdvantages}. Aunque
las desventajas también mencionen un pequeño impacto en el rendimiento y la
posibilidad de caer en un \emph{dependency hell}, sigue siendo una buena idea al
menos considerarlo para Tremor.

\section{Metodología}

\subsection{Organización}

El proyecto ha tenido una duración de unos 10 meses, comenzando en agosto de
2021 y terminando en mayo/junio de 2022. Su realización ha sido completamente
remota y con horarios muy flexibles. Se usó el servidor de Discord de
Tremor\footnote{\url{https://discord.com/invite/Wjqu5H9rhQ}} como plataforma
principal para comunicarse, tanto por texto como por videollamada. Se programó
una llamada por semana, en la que explicaba mi progreso y recibía ayuda de mis
mentores en caso de que me hubiera quedado atascado en algún momento.

% TODO: update Matthias' title
Disponía de tres mentores, que me guiaban en el proceso de desarrollo: Darach
Ennis (\emph{Principal Engineer and Director of Tremor Project}), Matthias Wahl
(\emph{Staff Engineer}) y Heinz N. Gies (\emph{Senior Staff Engineer}), todos
empleados por Wayfair.

La organización de forma más estructurada para las tareas que tenía pendientes,
en las que estaba trabajando en ese momento, y las que ya había realizado, se
basó principalmente en un Kanban en
GitHub\footnote{\url{https://github.com/marioortizmanero/tremor-runtime/projects/1}}.

\subsection{Desarrollo}

Para reducir el coste de desarrollo y asegurarse de que el proceso sea
completamente seguro (en memoria y concurrencia), el sistema de plugins
aprovecha librerías existentes en Rust y herramientas como macros procedurales.
El sistema de compilación usado es solución oficial de Rust: Cargo, que también
incluye un \emph{formatter}, \emph{linter}, y extensiones instalables creadas
por la comunidad. Adicionalmente, existe una gran cantidad de tests y
\emph{benchmarks} que se han de tener en cuenta para mantener el \emph{Code
Coverage} (la cantidad de código cubierta por los tests) y el rendimiento.

\subsection{Recursos públicos}

% TODO: actualizar '5' cuando suba el nuevo
% TODO: actualizar minutos de lectura
% TODO: buscar otra métrica que no sean horas de lectura, no creo que sea buena
% manera de venderlo
Este trabajo está disponible públicamente al completo. Además, a medida que he
investigado e implementado el sistema de plugins, he ido escribiendo todo en mi
blog personal, \emph{NullDeref}. Dispone de una serie con un total de 6
artículos, cada uno de unos 30 minutos de lectura. Gran parte del contenido de
este documento se obtiene de ahí, omitiendo en lo posible detalles específicos
al código, dado que aquí no se asume familiaridad con Rust. La organización
también difiere considerablemente, puesto que los artículos se escribieron a
medida que se realizaba el proyecto, resultando en una estructura menos
estricta. Esto toma un formato de tesis, mientras que el blog cuenta la historia
cronológicamente y sirve mejor como un tutorial para alguien que quiera
implementar un sistema de plugins propio.

\begin{itemize}
    \item El repositorio de GitHub para el binario de Tremor:\\
        \url{https://github.com/tremor-rs/tremor-runtime}
    \item Mi \emph{fork}, con ramas adicionales usadas durante el desarrollo:\\
        \url{https://github.com/marioortizmanero/tremor-runtime}
    \item Mi repositorio con experimentos antes de implementar la versión
        definitiva:\\
        \url{https://github.com/marioortizmanero/pdk-experiments}
    \item La serie de artículos en mi blog personal:\\
        \url{https://nullderef.com/series/rust-plugins/}.
\end{itemize}

Se recomienda también consultar el Anexo~\ref{annex:contributions}, que lista
todas las contribuciones de código abierto realizadas durante este proyecto.

TODO: debería ser más específico sobre las horas? Mucha cuenta no he llevado
pero vamos sí que estoy segurísimo de que han sido 300 horas y mucho más
también.

TODO: quizá hacer una tabla que relacione cada sección del índice con los
capítulos relacionados de nullderef? Pero eso ya lo pondría en un anexo.
