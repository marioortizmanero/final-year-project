% vim: spelllang=es

\chapter{Investigación previa}\label{sec:investigation}

La propuesta para el sistema de plugins asumía que se iba a implementar con un
método que cubriré posteriormente denominado \emph{cargado dinámico}. Esto se
debe a razones de rendimiento, pero el método también incluye otros problemas
importantes, principalmente relacionados con seguridad. Por ello, es una buena
idea considerar las alternativas existentes para el PDK, en caso de que hubiera
alguno con la misma eficiencia pero menos vulnerabilidades.

Los requerimientos mínimos a tener en cuenta son los siguientes:

\begin{itemize}
    \item Debe ser posible añadir y quitar plugins tanto en el inicio del
        programa como durante su ejecución.

    \item Disponibilidad y madurez en el ecosistema de Rust.

    \item Soporte multi-plataforma: Windows, MacOS y Linux.

    \item No debe tener un impacto excesivo en el rendimiento. Esto significa
        que los eventos no se pueden copiar en ningún momento.

\end{itemize}

Y opcionalmente:

\begin{itemize}
    \item Maximizar la seguridad en lo posible, como se especifica en la sección
        \ref{sec:security}.

    \item Debería ser retro-compatible con el código ya existente, como indica la
        sección \ref{sec:compat}.

    \item Minimizar el esfuerzo necesario para reescribir los conectores para el
        nuevo sistema de plugins.

\end{itemize}

\section{Seguridad}\label{sec:security}

\subsection{Código \unsafe}

Muchas de las tecnologías que se pueden aplicar para un sistema de plugins usan
código \unsafe. Técnicamente, esto no es necesariamente un problema si la
implementación está autocontenida y auditada exhaustivamente, pero se pierden
algunas garantías que proporcionadas por Rust, incrementando el coste de
mantenimiento de la librería.

Asegurarse de que la implementación es segura implica una cantidad
considerablemente mayor de trabajo, aun cuando existen herramientas como
MIRI\footnote{\url{https://github.com/rust-lang/miri}} --- que integraría en
Tremor en caso de tener que recurrir a \unsafe.

\subsection{Resiliencia a errores}

Rust no protege a sus usuarios de \leaks de memoria. De hecho, es tan sencillo
como llamar a \code{mem::forget}. Si un plugin tuviera un \leak, el proceso
entero también se vería afectado; el rendimiento de Tremor se degradaría con
plugins no desarrollados incorrectamente. Algo similar podría suceder en caso de
que un plugin abortase o sufriese de un \panic, lo que terminaría la ejecución
del programa por completo.

Idealmente, Tremor debería poder detectar plugins que no rinden óptimamente y
pararlos antes de que sea demasiado tarde. La runtime debería poder continuar
corriendo aun cuando falle un plugin, posiblemente avisando al usuario o
reiniciándolo para seguir funcionando.

\subsection{Ejecución de código remota a través de plugins}

Uno de los casos más notorios se dio con Internet Explorer, que usaba COM y
ActiveX, los cuales no disponían de una \sandbox. Dicho mecanismo aisla por
completo parte del programa, de forma que no pueda acceder a memoria externa
(evitando acceder a información que no es suya), ni a recursos del sistema (como
ficheros). Por tanto, extensiones maliciosas para el navegador podían ejecutar
código arbitrario en la máquina en la que estuviera instalado~\cite{iesandbox}.
Este problema puede ser menos grave si solo se instalan extensiones de confianza
con firmas digitales, pero sigue siendo un vector de ataque importante.

Se podría aplicar lo mismo a Tremor. El usuario del producto --- aquellos que
añadan plugins a su configuración ---, es un desarrollador, que debería ser más
consciente sobre lo que incluye en sus proyectos. Sin embargo, en la práctica
esto no es cierto.

Podría compararse con cómo funcionan los administradores de paquetes como
npm\footnote{\url{https://www.npmjs.com/}}. Su infraestructura se suele basar
por completo en cadenas de confianza; no hay nadie que te impida crear un
paquete malicioso para ejecutar código remoto o robar
credenciales~\cite{npm1}\cite{npm2}. Los plugins son como dependencias en este
caso; tienen acceso completo a la máquina donde se ejecutan, y por tanto no
deberían ser de confianza por defecto.

% TODO: puedo usar expresiones como 'terreno pantanoso' o es demasiado informal?
Una alternativa mejorada a Node y npm sería algo como
Deno\footnote{\url{https://github.com/denoland/deno}}, que es una runtime segura
por defecto. Esto es posible gracias a \sandboxing, y requiere que el
desarrollador active manualmente, por ejemplo, acceso al sistema de ficheros o a
la red. No es una solución infalible porque puede que los desarrolladores acaben
activando los permisos que necesitan sin pensarlo, pero es un mecanismo similar
a \unsafe: al menos te hace consciente de que estás en terreno pantanoso.

Se podría discutir que, realísticamente, el programa va a ejecutarse la mayoría
de los casos en una máquina virtual o un contenedor, donde este problema no es
tan peligroso. Pero, ¿debería la seguridad del usuario recaer en el hecho de que
el kernel está isolado? Por no mencionar que un contenedor afecta mucho más al
rendimiento que algunos métodos de \sandboxing. Aunque el sistema por completo
estuviera isolado, seguiría habiendo una posibilidad de \leaks internos: el
plugin de Postgres tiene acceso a todo lo que esté usando el plugin de Apacha
Kafka, que posiblemente tenga \emph{logs} sensitivos.

\section{Retro-compatibilidad}\label{sec:compat}

Será necesario incluir algún tipo de gestión de versiones en el proyecto. Es
probable que la interfaz de Tremor cambie con frecuencia, lo que romperá plugins
basados en versiones previas. Si un plugin recibe una estructura de la runtime,
pero esta estructura perdiese uno de sus campos en una nueva versión, se estará
invocando comportamiento no definido.

\subsection{Posibles soluciones}

La idea más sencilla para arreglar problemas con retrocompatibilidad es
serializar y deserializar los datos con un protocolo flexible, en vez de usando
su representación binaria directamente. Si se usara un protocolo como JSON para
comunicarse entre la runtime y los plugins, añadir un campo no rompería nada, y
eliminar uno puede ocurrir mediante un proceso de deprecación. Por desgracia,
esto implicaría una degradación en el rendimiento que posiblemente no interese
en la aplicación. Otros arreglos más elaborados para representaciones binarias
incluyen~\cite{swiftabi}:

\begin{itemize}
    \item Reservar espacio en la estructura para uso futuro.

    \item Hacer la estructura un tipo opaco, es decir, que sólo se puede acceder
        a sus campos con llamadas a funciones, en lugar de directamente.

    \item Dar a la estructura un puntero a sus datos en la ``segunda versión''
        (lo cual sería opaco en la ``primera versión'').

\end{itemize}

\subsection{Evitar errores}

Hay casos donde un error inevitable. Es posible que Tremor quiera reescribir
parte de su interfaz o finalmente eliminar una funcionalidad deprecada sin tener
que preocuparse por romper todos los plugins desarrollados previamente.

Para ello, los plugins deben incluir metadatos sobre las diferentes versiones
de rustc/interfaz/etc para las que fue desarrollado. Después, cuando sean
cargados por Tremor, se podrá comprobar su compatibilidad, en vez de romperse de
formas misteriosas.

\section{Tecnologías a considerar}

Esta sección describe las tecnologías que se han considerado más viables como
base para el PDK. Algunas de ellas no cumplirán los requerimientos mencionados
al principio del capítulo, pero es necesario aprender sobre ellas primero antes
de escribir ninguna línea de código.

\subsection{Lenguajes interpretados}

Todo tipo de proyectos usan lenguajes interpretados para extender su
funcionalidad a tiempo de ejecución, como Python, Ruby, Perl, Bash, o
JavaScript. Particularmente, el editor de texto Vim creó su propio lenguaje para
poderlo personalizar por completo, Vimscript~\cite{vimscript}. Ahora NeoVim, un
fork más moderno, está esforzándose por tener Lua como lenguaje de primera clase
para su configuración~\cite{nvimlua}. Incluso Tremor tiene su propio lenguaje
para configurarlo, Troy.

% TODO: alguna traducción de 'embedding' decente?
De todos los lenguajes disponibles, Lua sería una de las mejores opciones para
este sistema de plugins en específico. Está hecho con \emph{embedding} en mente:
es simple y únicamente alrededor de 220KB~\cite{ierusalimschy2006programming}.
Algunas implementaciones del lenguaje, como LuaJIT, son extremadamente
eficientes y pueden ser viables hasta en escenarios de rendimiento
crítico~\cite{luajitperf}. Adicionalmente, las garantías de seguridad de Lua son
más fuertes que otros lenguajes, dado que no requiere \unsafe y que incluye una
\sandbox (aunque es ``delicado y difícil de configurar
correctamente'')~\cite{luasandboxes}.

Rust dispone de librerías como \cratelink{rlua}, con bindings para interoperar
con Lua. \code{rlua} en particular parece enfocar su interfaz en ser idiomática
y segura, que es un punto positivo para una librería fuertemente relacionada con
C. Por desgracia, parece estar semi-abandonada y fue reemplazada por
\cratelink{mlua}. Por lo general, el ecosistema de Lua en Rust no parece lo
suficientemente maduro para un proyecto como este; aún queda trabajo para
mejorar la estabilidad.

También sería posible usar uno de los lenguajes interpretados creados
específicamente para Rust: \textcite{cratesiogluon}, \textcite{cratesiorhai} o
\textcite{cratesiorune}. Usarlos posiblemente resulte en código más limpio y
simple. Sin embargo, su ecosistema todavía está en su infancia y ninguna de las
opciones son tan estables o seguras como lenguajes de programación de propósito
general. Rhai, el más usado, anunció su versión v1.0 en julio de 2021 y no
sobrepasa las 200.000 descargas, mientras que Lua fue creado en 1993 y es uno de
los 20 lenguajes más famosos, según el \textcite{tiobe}.

De cualquier manera, portar el código a este sistema de plugins sería un trabajo
excesivamente laborioso. Todos los conectores tendrían que reescribirse por
completo a un lenguaje distinto. Para un proyecto nuevo sería una alternativa
interesante, pero ciertamente no lo es en el caso de Tremor.

\subsection{WebAssembly}

\textcite{wasm}, también conocido como Wasm, es esencialmente un formato binario
abierto y portable. A diferencia de binarios normales, el mismo ejecutable Wasm
puede correr en cualquier plataforma, siempre y cuando exista una runtime que lo
soporte. Comenzó como una alternativa a JavaScript exclusiva a la web, pero ha
evolucionado con el tiempo y ahora es posible usarlo en el escritorio gracias a
\textcite{wasi}.

Los objetivos de Wasm son maximizar la portabilidad y seguridad, sin un coste de
rendimiento excesivo. Su diseño incluye una \sandbox para lidiar con programas
no fiables, como es el caso en sistemas de plugins, y apenas no requiere usar
\unsafe. Ya que puede ser compilado desde otros lenguajes como Rust o C, el
código existente en Tremor podría ser reusado (lo cual era imposible con
lenguajes de \scripting).

Existen dos runtimes principales para Rust: \textcite{wasmer} y
\textcite{wasmtime}. Ambas son implementaciones competitivas que se enfocan a
unos u otros casos de uso. Por lo general, Wasmer es más adecuado para embebirlo
en programas nativos, mientras que Wasmtime se centra en programas individuales
--- aunque los dos se pueden usar apara ambos casos~\cite{wasmwikiusage}.

% TODO: quizá esta footnote es innecesaria; podría llamarlo `intérprete` y ya.
WebAssembly todavía es una tecnología relativamente nueva, así que algunas
partes siguen bajo desarrollo continuo y necesitan mejoras, como en rendimiento.
En comparación a JavaScript, \textcite{jangda2019not} muestra resultados
mezclados al realizar pruebas de rendimiento. Depende principalmente del
compilador\footnote{Nos referimos también a la runtime como un
\emph{compilador}, dado que las implementaciones más eficientes y populares son
intérpretes \emph{Just-In-Time} (JIT), que transforman partes del código fuente
a código máquina.} y del entorno que se esté usando, variando desde mejoras en
velocidad de 1.67x en Chrome, a 11.71x con Firefox. Cuando se compara contra
código nativo, \textcite{libsodiumwasmperf} describe una varianza similar, donde
Wasmer es 2.47x más lento y con Wasmtime es 3.28x. En resumen, mientras que
WebAssembly es una solución más eficiente que algunos lenguajes de \scripting,
sigue sin llegar al nivel de binarios nativos, y posiblemente no sea lo
suficiente para este caso.

Esta tecnología es de las más adecuadas encontradas por el momento; su único
problema es el rendimiento. Tras implementar algún sistema de plugins en
miniatura, su usabilidad era excelente. Si fuera posible transferir datos entre
la runtime y el plugin sin tener que copiarlos, sería definitivamente la mejor
alternativa.

La especificación de WebAssembly define únicamente enteros y decimales como sus
tipos disponibles~\cite{wasmertypes}. Existen algunas maneras de tratar tipos no
triviales como estructuras o enumeraciones:

\begin{itemize}
    \item A través de la \textcite{wasminterfacetypes}. Esta define un formato
        binario para codificar y decodificar los nuevos tipos que define: tipos
        de números más especializados, caracteres individuales, listas,
        estructuras y enumeraciones. También especifica una lista de
        instrucciones para transformar los datos entre WebAssembly y el mundo
        exterior. Notar que esta propuesta no intenta definir una representación
        fija de, por ejemplo, una cadena de caracteres en Wasm; intenta permitir
        tipos de alto nivel agnósticos a su representación.

        Adicionalmente, las interfaces se pueden definir independientemente del
        lenguaje de programación que se esté usando, gracias al formato
        \code{witx}~\cite{witx}, como muestra la Figura~\ref{fig:witx_example}.

        El mayor problema de esta solución es que aún está en ``Fase 1'': aún
        necesita mucho trabajo y su especificación no es estable. Ninguna de las
        runtimes tienen soporte para esta propuesta
        aún~\cite{interfacetypeswasmtime}\cite{interfacetypeswasmer}. Tras
        fallar al intentar usarlo, esta opción fue descartada.

    \item La forma actualmente funcional pero imperfecta, con punteros y memoria
        compartida. El usuario debe construir y serializar el tipo complejo y
        después guardarlo en la memoria reservada para Wasm, a la que la runtime
        puede acceder directamente con punteros. Esto es lo que otros sistemas
        de plugins como Feather o Veloren
        hacen~\cite{featherpluginsystem}\cite{velorenpluginsystem}, así que es
        garantizado que funciona.

        No sólo requiere esto un paso de serialización y otro de deserialización
        y escribir y leer todos los datos de una memoria, sino que también es
        una tarea ardua y complicado de hacer correctamente. A nivel de
        rendimiento esto implicaría copiar los datos, así que no es algo que
        Tremor se pueda permitir.

    \item Otra opción que usan programas como Zellij~\cite{zellijpluginsystem},
        que usa un ejecutable de Wasm en vez de usarlo como una librería. Para
        cargarlo, lo ejecuta y usa \stdin y \stdout para los flujos de datos.
        Por desgracia, esto también requiere copiar datos, y tiene que
        descartarse.

\end{itemize}

\begin{figure}
    \centering
    \begin{minted}{lisp}
(use "errno.witx")

;;; Add two integers
(module $calculator
  (@interface func (export "add")
    (param $lh s32)
    (param $rh s32)
    (result $error $errno)
    (result $res s32)
  )
)
    \end{minted}
    \caption{Ejemplo de interfaz definida con \code{witx}.}%
    \label{fig:witx_example}
\end{figure}

\subsection{eBPF}

eBPF es ``a revolutionary technology with origins in the Linux kernel that can
run sandboxed programs in an operating system kernel''~\cite{ebpf}. Sin embargo,
de forma similar a WebAssembly, su uso se ha extendido a \emph{user-space}. eBPF
define una lista de instrucciones que pueden ejecutarse por una máquina virtual,
también como WebAssembly funciona.

Esta tecnología es prometedora, ya que a diferencia de WebAssembly, no es
necesario serializar o deserializar los datos o escribirlos a una memoria
intermedia. Ya que existe control completo sobre la máquina virtual, la runtime
podría implementar una \sandbox personalizada para comprobar las direcciones de
memoria de donde se lee o escribe para asegurarse de que se encuentran en el
rango permitiendo, siendo posible compartir una única memoria. La única
penalización en el rendimiento sería interpretar las instrucciones en vez de
ejecutar código nativo, pero técnicamente Tremor sí que podría usarlo.

El problema principal con eBPF es que su suporte es carente. La mayoría de sus
usuarios usan C y lo muestra la poca cantidad de tutoriales, guías, artículos o
incluso librerías disponibles para Rust. No es posible compilar Rust a
instrucciones eBPF de forma oficial y la única runtime disponible es
\cratelink{rbpf} y derivados como \cratelink{solana_rbpf}, ya que este primero
parece estar obsoleto. Además, supondría un esfuerzo mucho mayor que
WebAssembly, ya que también requeriría implementar una \sandbox personalizada.

\subsection{Comunicación Inter-Proceso}

Otra opción popular para sistemas de plugins es la \emph{Comunicación
Inter-Proceso}, que divide el programa en un cliente y un servidor en procesos
distintos. El cliente actuaría como runtime y estaría conectado a múltiples
servidores que proporcionan la funcionalidad. Se podría comparar con el
\emph{Language Server
Protocol}\footnote{\url{https://microsoft.github.io/language-server-protocol/}},
basado en JSON-RPC y usado por la mayoría de editores de texto para tener
soporte especializado para cualquier lenguaje de programación.

Una ventaja común para todos los métodos de esta familia es que, de forma
similar a WebAssembly, los plugins se podrán escribir en Rust, así que el código
existente se podría reusar. Además, ya que el cliente y servidor se dividirían
en múltiples procesos, serían más seguros por lo general; plugins defectuosos no
afectarían a la runtime de Tremor.

\subsubsection{Sockets}

Son los que peor rendimiento tienen de acuerdo a la Figura
\ref{fig:ipc_comparison1} y la Figura \ref{fig:ipc_comparison2}, pero también
son los más famosos, y consecuentemente, los más fáciles de usar. Los \sockets
son la misma tecnología usada en cualquier servidor para comunicarse con un
cliente y viceversa, por lo que hay una cantidad enorme de implementaciones
disponibles.

\begin{figure}
    \centering
    \includegraphics[width=12cm]{./Imagenes/venkataraman2015evaluation1.png}
    \caption{Latencia vs. Tamaño de Mensaje \cite{venkataraman2015evaluation}.}%
    \label{fig:ipc_comparison1}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=12cm]{./Imagenes/venkataraman2015evaluation2.png}
    \caption{Rendimiento vs. Tamaño de Mensaje
    \cite{venkataraman2015evaluation}.}%
    \label{fig:ipc_comparison2}
\end{figure}

Usar \sockets también requiere un paso de deserialización, dado que los datos se
envían en paquetes. Formatos como JSON son los más flexibles, pero otros como
\textcite{protobuf} son ligeros y tienen mejor rendimiento.

\subsubsection{Pipes}

Para un sistema de plugins, las \pipes son muy similares a los \sockets, con la
única diferencia siendo que las \pipes solo se pueden usar en una misma máquina.
Con \sockets, técnicamente podrías usar TCP o UDP y tener la runtime y los
plugins en ordenadores distintos. Esto no es algo necesario para el caso de
Tremor, y ya que las \pipes ofrecen un mejor rendimiento, posiblemente sean una
mejor opción por lo general.

Por ejemplo, el gestor de archivos
nnn\footnote{\url{https://github.com/jarun/nnn}} usa este método: los plugins
pueden leer de una FIFO (una \pipe con nombre) para recibir las selecciones de
archivos o directorios que realice el usuario e implementar su funcionalidad
adicional.

La única desventaja es que no parecen haber librerías populares para la
funcionalidad genérica de \pipes (quizá \cratelink{interprocess} o
\cratelink{ipipe}). Sin embargo, esto podría ser innecesario si se usaran las
\pipes de \stdin, \stdout o \stderr implícitamente, ya que tienen soporte en la
librería estándar al ejecutar comandos \emph{shell}~\cite{rustpipes}.

\subsubsection{Memoria compartida}

Como el nombre indica, la memoria compartida consiste en inicializar un buffer
del que se puede leer y escribir desde dos o más procesos al mismo tiempo para
comunicarse. El API de memoria compartida se implementa a nivel del kernel, por
lo que depende mucho del sistema operativo y posiblemente no sea tan portable
como otras soluciones.

Tal y como indican las
Figuras~\ref{fig:ipc_comparison1}~y~\ref{fig:ipc_comparison2}, es el método con
mejor rendimiento, ya que no requiere copiar ni transformar datos entre
procesos. El único coste adicional es la inicialización de las páginas
compartidas en el sistema operativo, que se debe hacer únicamente al
principio~\cite{sharedmemperf}.

Desgraciadamente, el soporte para memoria compartida en Rust es casi
inexistente. Las únicas \crates disponibles son \cratelink{shared_memory} y
\cratelink{raw_sync}, que no superan las 150.000 descargas en total y usan gran
cantidad de \unsafe. Esto probablemente tenga que ver con el hecho de que
comparte los mismos problemas que cargado dinámico respecto a estabilidad de ABI
(explicado en la sección~\ref{sec:dynload}). No parece ofrecer nada mejor que el
cargado dinámico y por tanto se descarta como opción.

\subsection{Cargado dinámico}\label{sec:dynload}

Esta es la manera más popular para implementar un sistema de plugins, al menos
fuera de Rust. Una \emph{Foreign Function Interface} (FFI) nos permite acceder
directamente a recursos en objetos compilados separadamente, aun después de la
fase de \emph{linking}, gracias al cargado dinámico. Es una de las opciones más
eficientes porque no implica casi ningún coste adicinal tras cargar la librería
dinámica.

La \crate principal para este método es \cratelink{libloading}, aunque también
existen las menos conocidas \cratelink{dlopen} y \crate{sharedlib}, con pequeñas
diferencias~\cite{cratesdynloadcompare}. Todas ellas requieren de uso extensivo
de \unsafe, son complicadas de usar
correctamente~\cite{hardplugins1}\cite{hardplugins2}, incluyendo sutiles
disparidades entre sistemas operativos~\cite{hardplugins3}, ni disponen de un
mecanismo similar a una \sandbox. La única manera de mejorar la usabilidad será
a través de los macros y herramientas facilitados por algunas librerías.

\subsubsection{Estabilidad del ABI}\label{sec:abi}

El problema principal con esta alternativa es que Rust carece de un
\emph{Application Binary Interface} (ABI) estable. El ABI es una interfaz entre
dos módulos binarios, en nuestro caso entre un ejecutable (runtime) y una
librería dinámica (plugin). Este se encarga de definir, entre otros, la
estructura que siguen los tipos en memoria y la convención usada para llamar
funciones. Sin un ABI definido (y por tanto, \emph{estable}), sería imposible
saber cómo acceder a los recursos de otros binarios.

En el comienzo este proyecto, gran cantidad de fuentes en la comunidad
confundían cómo funciona este concepto en Rust, y lo explicaban de forma
incorrecta~\cite{wrongabi1}\cite{wrongabi2}\cite{wrongabi3}\cite{wrongabi4}.
Este popular malentendido también se dio en la propuesta del PDK y no nos dimos
cuenta del verdadero significado hasta haber invertido numerosas horas. El
equipo de Tremor --- yo incluido --- creía que el ABI de Rust es estable,
siempre que los dos binarios se compilen con la misma versión de compilador. Sin
embargo, esto es incorrecto por varias razones y fuentes como la referencia
oficial no entran en suficiente detalle~\cite{refabi_abi}. Debe recurrirse a
otra sección que menciona brevemente lo siguiente:

``La estructura de tipos en memoria puede cambiar con cada compilación. En vez
de intentar documentar exactamente qué se hace, se documenta solo lo que se
garantiza hoy''~\cite{refabi_layout}

La asumpción anterior incorrecta se basa en que, hasta el momento, Rust no ha
implementado ninguna optimización que rompa el ABI entre ejecuciones de un mismo
compilador. Pero no existe absolutamente ninguna garantía de que esto sea así, y
es un detalle de implementación del compilador del que no debería confiarse. Es
posible que este comportamiento sí que se rompa en el
futuro~\cite{randomizelayout}, en cuyo caso el sistema de plugins tendría que
reescribirse por completo.

% TODO: a lo mejor lo de órdenes de magnitud se podría cambiar por algo mejor
Descubrir esto implicó un cambio de planes y un aumento en la complejidad del
proyecto de órdenes de magnitud. Ahora tendría que recurrirse a una ABI que sí
que tuviera garantías de estabilidad, y traducir entre la de Rust y esta para
comunicarse entre runtime y plugins. La ABI más conocida es la del lenguaje de
programación C, que se puede acceder desde Rust como indican las
Figuras~\ref{fig:rustpure}~y~\ref{fig:rustffi}.

\begin{figure}
    \centering
    \begin{minted}{rust}
pub struct Event {
    pub count: i32,
    pub name: &'static str,
}

pub fn transform(x: Event) -> i32 {
    println!("Received an event with count {}", x.count);
    x.count
}

pub static cached: Event = Event {
    count: 0,
    name: "my data"
};
    \end{minted}

    \caption{Ejemplo de cómo sería un plugin escrito con Rust.}%
    \label{fig:rustpure}
\end{figure}

\begin{figure}
    \centering
    \begin{minted}{rust}
// Using C's memory layout with `#[repr]`
#[repr(C)]
pub struct Event {
    // We can't have types from the standard library anymore, only
    // either basic ones...
    pub count: i32,
    // ...or types from C itself
    pub name: *const std::os::raw::char_c,
}

// Using C's calling conventions with `extern "C"`
pub extern "C" fn transform(x: Event) -> i32 {
    println!("Received an event with count {}", x.count);
    x.count
}

// Disabling mangling so that the resource's name is known when
// loading the plugin.
#[no_mangle]
pub static cached: Event = Event {
    count: 0,
    name: "my data".as_ptr() as _
};
    \end{minted}

    \caption{El mismo plugin que la Figura~\ref{fig:rustpure}, pero usando el
    ABI de C.}%
    \label{fig:rustffi}
\end{figure}

\subsubsection{Herramientas disponibles}

Todo este proyecto va a ser posible gracias a una \crate de más alto nivel,
\cratelink{abi_stable}. Esta usa \code{libloading} internamente y exporta una
gran cantidad de macros y herramientas para facilitar el desarrollo. También
incluye una copia de la librería estándar de Rust declarada con el ABI de C, por
lo que podremos usar el tipo vector \code{RVec<T>} en vez de un puntero
\code{*const T} sin tener que reescribirlo nosotros mismos. También incluye
soporte para librerías externas muy conocidas en la comunidad, como
\cratelink{crossbeam} o \cratelink{serde_json}. La
Figura~\ref{fig:rustabi_stable} demuestra parte de la simplificación del código
en la Figura~\ref{fig:rustffi}.

Existen algunas alternativas o extensiones de \code{abi_stable} como
\code{lccc}\footnote{\url{https://github.com/LightningCreations/lccc}},
\cratelink{safer_ffi} o \cratelink{cglue} que se tuvieron en cuenta, pero no son
soluciones tan completas ni maduras, por lo que no serán incluidas en este
proyecto. \code{abi_stable} se trata de una librería compleja, con más de 50.000
líneas de código en Rust (como referencia, Tremor tiene unas 35.000 líneas), lo
cual deberá tenerse en cuenta en la decisión final también.

\begin{figure}
    \centering
    \begin{minted}{rust}
// Now we also "derive" the trait StableAbi, i.e., it's implemented
// automatically.
#[repr(C)]
#[derive(StableAbi)]
pub struct Event {
    pub count: i32,
    // We can use abi_stable's types!
    pub name: RStr<'static>,
}

// Using C's calling conventions with `extern "C"`
#[sabi_extern_fn]
pub fn transform(x: Event) -> i32 {
    println!("Received an event with count {}", x.count);
    x.count
}
    \end{minted}

    \caption{El mismo plugin que la Figura~\ref{fig:rustpure}, pero con
        \code{abi_stable}. La declaración de la global \code{cached} se omite por
        simplicidad.}%
    \label{fig:rustabi_stable}
\end{figure}

\section{Sistemas de plugins de referencia}

Otro punto de estudio importante es qué plugins ya hay existentes en Rust y cómo
se han realizado:

\begin{itemize}
    \item El mismo Cargo o
        \code{mdbook}\footnote{\url{https://github.com/rust-lang/mdBook}}
        implementan un sistema de extensiones a través de la línea de comandos.
        Añadir un subcomando nuevo es tan sencillo como crear un binario con un
        prefijo establecido (e.g., \code{cargo-expand}). Si está disponible en
        la variable de entorno \code{PATH} al ejecutar \code{cargo}, se podrá
        invocar al plugin con \code{cargo expand} también. Es una manera
        especialmente simple y creativa de usar \pipes con IPC, dado que usa
        \stdin y \stdout para comunicarse con la runtime.

    \item \code{zellij}\footnote{\url{https://github.com/zellij-org/zellij}} es
        un entorno de trabajo en el terminal con ``un sistema de plugins que
        permite crear plugins en cualquier lenguaje que compile a WebAssembly''.
        De forma similar al caso anterior, funciona un binario distinto para
        cada plugin y el ejecutable principal ejecuta el código en WebAssembly,
        comunicándose con \stdin y \stdout.

    \item \code{xi}\footnote{\url{https://github.com/xi-editor/xi-editor}} es un
        editor de texto moderno ahora abandonado. Usa RPC con mensajes JSON para
        comunicarse con plugins en procesos distintos~\cite{xiplugin}, método
        también usado en Visual Studio Code~\cite{vscodeplugin} o
        Eclipse~\cite{eclipseplugin}.

    \item \cratelink{bevy} es un motor de videojuegos prometedor cuyas
        prestaciones se implementan como plugins. En la mayoría de los casos, se
        cargan en tiempo de compilación, pero \code{bevy::dynamic_plugin}
        da la posibilidad de hacerlo dinámicamente. \code{bevy} se basa en la
        falsa estabilidad del ABI explicado en la sección~\ref{sec:abi} y
        únicamente usa tipos definidos en Rust.

        Otras fuentes como \textcite{dynloading1} o \textcite{dynloading2}
        también intentan usar cargado dinámico para funcionalidades similares.
        Este último se trata de \cratelink{amethyst}, el predecesor de
        \code{bevy}, que acabó rindiéndose debido a la inestabilidad del
        ABI~\cite{dynloading_giveup1}\cite{dynloading_giveup2}.

\end{itemize}

\section{Elección Final}

Tras implementar varios sistemas de plugins en miniatura con las tecnologías más
prometedoras mencionadas en este capítulo, se tomó la decisión de usar cargado
dinámico con \code{abi_stable}. Cada alternativa tiene sus puntos fuertes y sus
puntos flojos, como ilustra la Figura~\ref{fig:triangle}, pero ninguna de las
demás terminaron de cumplir los requisitos de rendimiento establecidos por el
equipo de Tremor.

Todas las tecnologías excepto cargado dinámico, eBPF o memoria compartida
requieren la copia de los datos en algún momento, algo que Tremor no se puede
permitir. De esas tres posibles soluciones, todas tienen que lidiar con
problemas con el ABI. La que mejor soporte tiene es cargado dinámico, así que
ese será el camino tomado.

\begin{figure}
    \centering
    \includegraphics[width=10cm]{./Imagenes/triangle.pdf}
    \caption{Comparación aproximada de los métodos investigados.}%
    \label{fig:triangle}
\end{figure}
