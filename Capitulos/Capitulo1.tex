% vim: spelllang=es

\chapter{Breve introducción a Rust}\label{ch:rust}

Dado que Rust es un lenguaje de programación que tan solo anunció su primera
versión en 2015, aún no es conocido por muchos desarrolladores. Este proyecto
requiere ser familiar con cómo funciona, por lo que en este capítulo se
introducirán los conceptos más básicos necesarios. Sí que se asume conocimiento
de lenguajes de propósito general, como C, C++, Python o Java.

Sin embargo, es posible que se omitan algunos conceptos o que algunas
explicaciones no sean completamente precisas por razones de simplicidad.
\textcite{rustfullbook} es el libro oficial para aprender Rust por completo,
pero es una lectura larga y posiblemente demasiado exhaustiva. Para mayor
brevedad, se recomienda leer \textcite{rustprofessionals},
\textcite{rustgentleintro} o \textcite{rust30min}.

La comunidad dispone de otros libros que explican aspectos más avanzados del
lenguaje en específico, como \unsafe o la programación asíncrona. En esos casos,
se recomienda leer \textcite{rustnomicon} y \textcite{rustasyncbook},
respectivamente.

TODO: revisar traducciones del libro o similares para asegurarse de que la
terminología es la misma.

\section{¿Qué es Rust?}

Rust es un lenguaje de programación de sistemas compilado y de propósito
general. Su objetivo es maximizar rendimiento y usabilidad, esto último
basándose en seguridad integrada en el lenguaje, en vez de en el \

\section{Primeros pasos}

Comenzando por el clásico ``Hola Mundo'', se incluyen algunos ejemplos de cómo
es la sintaxis de Rust más básica. El programa se podría ejecutar fácilmente con
\emph{Cargo}, el administrador de dependencias oficial, o específicamente con el
comando \code{cargo run}.

\begin{minted}{rust}
fn main() {
    println!("Hello World!");
}
\end{minted}

\code{main} es nuestra función principal, que invoca al macro \emph{println}
para escribir por pantalla. Esto se sabe porque, a diferencia de una llamada a
función, la invocación termina con una exclamación (\code{!}).

Los bloques básicos (\code{if}, \code{else}, \code{while}, \code{for}) son los
mismos que en otros lenguajes, con la introducción de \code{match}, que permite
extraer patrones.

\begin{minted}{rust}
fn factorial(i: u64) -> u64 {
    match i {
        0 => 1,
        n => n * factorial(n-1)
    }
}
\end{minted}

\section{Librería estándar}

De forma similar a C++, Rust posee tipos genéricos. Esto permite la
implementación de una librería estándar flexible, con varias estructuras de
datos importantes a conocer:

\begin{itemize}
    \item Tipos primitivos:
        \begin{itemize}
            \item Carácteres con \code{char}.

            \item Punto flotante con \code{f32} y \code{f64}.

            \item Booleanos con \code{bool}.

            \item Enteros: \code{u8}, \code{i8}, \code{u16}, \code{i16},
                \code{u32}, \code{i32}, \code{u64}, \code{i64}, e incluso
                \code{i128} y \code{u128} en las arquitecturas que lo soportan.

            \item Vectores de tamaño fijo: por ejemplo \code{[1, 2, 3, 4, 5]}.

            \item N-tuplas como \code{(1, true, 9.2)}.

            \item El tipo ``unidad'', \code{()}, equivalente a \code{void} en C
                o C++.

            \item Punteros básicos con \code{*const T} o \code{*mut T}.

        \end{itemize}

    \item \code{Vec<T>} representa un vector contiguo y redimensionable.

    \item \code{HashMap<K, V>} es una tabla hash, genérica respecto a su clave
        \code{K} y su valor \code{V}. No se encuentra en el preludio, por lo que
        requeriría la siguiente declaración, similar a un \code{import} de Java:

\begin{minted}{rust}
use std::collections::HashMap;
\end{minted}

    \item \code{Box<T>}, usado para localizar un tipo \code{T} en memoria.
        Incluye el tamaño que ocupa \code{T}.

    \item \code{str} es una cadena UTF-8 de solo lectura, típicamente usada con
        una referencia \code{&str}. Va acompañada por su longitud, por lo que no
        hace falta terminarla con \code{\0}, a diferencia de C. \code{String} es
        su versión modificable asignada en memoria.

\end{itemize}

\section{Gestión de errores}

En Rust, los errores se indican con el tipo \code{Result<T, E>}. Este se trata
de una enumeración cuyo valor puede ser \code{Ok(T)}, con el resultado obtenido
satisfactoriamente, o \code{Err(E)}, con el tipo de error que ha sucedido. Dado
que es un tipo nuevo, si el programador se olvidase de comprobar errores, el
programa no compilaría. Se puede usar \code{match} para comprobar el resultado,
o una serie de funciones disponibles para hacer el proceso más ergonómico:

\begin{minted}{rust}
match load_file(input) {
    Ok(data) => /* ... */,
    Err(e) => eprintln!("Error: {e}"),
}
\end{minted}

En caso de que se produjera un error del que el programa no se puediera
recuperar, como quedarse sin memoria o un fallo inesperado en la implementación,
se usa la funcionalidad de \emph{pánicos}. Un pánico se propaga de forma similar
a una excepción de C++ o Java, y terminará la ejecución por completo. Esto se
puede invocar con el macro \code{panic!} o utilidades similares.

\section{TODO}
